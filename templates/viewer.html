<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documenta â€” Viewer</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8f9fa;
        }

        .header {
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 15px 30px;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
        }

        .logo {
            font-size: 1.5rem;
            color: #667eea;
            font-weight: 600;
        }

        .header-actions {
            display: flex;
            gap: 15px;
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn.secondary {
            background: #6c757d;
        }

        .btn.secondary:hover {
            box-shadow: 0 5px 15px rgba(108, 117, 125, 0.3);
        }

        .main-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 30px;
            display: flex;
            gap: 0;
            margin-left: 300px;
            transition: margin-left 0.3s ease;
        }

        .main-content.sidebar-collapsed {
            margin-left: 0;
        }

        .sidebar {
            width: 300px;
            background: white;
            border-radius: 0;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            padding: 0;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            overflow-y: auto;
            overflow-x: hidden;
            flex-shrink: 0;
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        .sidebar.collapsed {
            transform: translateX(-100%);
        }

        .sidebar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 20px 15px 20px;
            border-bottom: 2px solid #e9ecef;
            background: #f8f9fa;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .sidebar-close {
            background: none;
            border: none;
            color: #6c757d;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.3s ease;
            display: none; /* Hidden by default on desktop */
        }

        .sidebar-close:hover {
            background: #e9ecef;
            color: #495057;
        }

        .sidebar-close:active {
            transform: scale(0.95);
        }

        .sidebar-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .sidebar-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
        }

        .sidebar-toggle:hover {
            background: #5a6fd8;
            transform: scale(1.1);
        }

        .sidebar-toggle.collapsed {
            left: 20px;
        }

        .toc-list {
            list-style: none;
            margin: 0;
            padding: 0;
            width: 100%;
            box-sizing: border-box;
        }

        .toc-item {
            margin-bottom: 4px;
            width: 100%;
            box-sizing: border-box;
        }

        .toc-group {
            margin-bottom: 8px;
        }

        .toc-group-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.95rem;
        }

        .toc-group-header:hover {
            background: #e9ecef;
        }

        .toc-group-header.expanded {
            background: #667eea;
            color: white;
        }

        .toc-group-toggle {
            background: none;
            border: none;
            color: inherit;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s ease;
        }

        .toc-group-toggle.expanded {
            transform: rotate(90deg);
        }

        .toc-group-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            margin-left: 16px;
            width: 100%;
            box-sizing: border-box;
        }

        .toc-group-content.expanded {
            max-height: 500px;
        }

        .toc-link {
            color: #6c757d;
            text-decoration: none;
            display: block;
            padding: 6px 12px;
            border-radius: 6px;
            transition: all 0.3s ease;
            font-size: 0.85rem;
            margin-left: 8px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }

        .toc-link:hover {
            background: #f8f9fa;
            color: #667eea;
        }

        .toc-link.active {
            background: #667eea;
            color: white;
        }

        /* Custom scrollbar for sidebar */
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* Firefox scrollbar */
        .sidebar {
            scrollbar-width: thin;
            scrollbar-color: #c1c1c1 #f1f1f1;
        }

        .content-area {
            flex: 1;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 40px;
            min-height: 800px;
            margin: 0 auto;
            max-width: 100%;
        }

        /* Ensure anchored headings do not hide beneath the sticky header */
        .content-area h1,
        .content-area h2,
        .content-area h3,
        .content-area h4,
        .content-area h5,
        .content-area h6 {
            scroll-margin-top: 100px; /* approx sticky header height + spacing */
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 400px;
            font-size: 1.2rem;
            color: #6c757d;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-right: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 1024px) {
            .main-content {
                margin-left: 0;
            }

            .sidebar {
                width: 100%;
                position: fixed;
                height: 100vh;
                z-index: 1001;
            }

            .sidebar-close {
                display: block; /* Always show close button on mobile */
            }

            .sidebar-toggle {
                display: block;
                z-index: 1002;
            }

            .content-area {
                margin: 0;
                padding: 20px;
                border-radius: 0;
            }
        }

        @media (max-width: 768px) {
            .header-content {
                padding: 15px;
                flex-direction: column;
                gap: 15px;
                align-items: flex-start;
            }

            .header-actions {
                width: 100%;
                justify-content: flex-start;
                gap: 10px;
            }

            .btn {
                padding: 8px 16px;
                font-size: 0.85rem;
            }

            .main-content {
                padding: 15px;
            }

            .content-area {
                padding: 20px;
                margin: 0;
            }

            .sidebar {
                width: 100%;
                max-width: 100vw;
            }

            .sidebar-header {
                padding: 15px;
            }

            .sidebar-title {
                font-size: 1.1rem;
            }

            .toc-list {
                padding: 0 15px;
            }

            .toc-item {
                margin-bottom: 8px;
            }

            .toc-link {
                padding: 8px 12px;
                font-size: 0.9rem;
            }

            .toc-group-header {
                padding: 10px 12px;
                font-size: 0.9rem;
            }

            .toc-group-content {
                margin-left: 12px;
            }

            .sidebar-toggle {
                top: 15px;
                left: 15px;
                width: 45px;
                height: 45px;
                font-size: 1.1rem;
            }
        }

        @media (max-width: 480px) {
            .header-content {
                padding: 12px;
            }

            .main-content {
                padding: 10px;
            }

            .content-area {
                padding: 15px;
            }

            .sidebar-header {
                padding: 12px;
            }

            .sidebar-title {
                font-size: 1rem;
            }

            .toc-list {
                padding: 0 12px;
            }

            .toc-link {
                padding: 6px 10px;
                font-size: 0.85rem;
            }

            .toc-group-header {
                padding: 8px 10px;
                font-size: 0.85rem;
            }

            .sidebar-toggle {
                top: 12px;
                left: 12px;
                width: 40px;
                height: 40px;
                font-size: 1rem;
            }

            .btn {
                padding: 6px 12px;
                font-size: 0.8rem;
            }
        }

        /* Touch-friendly improvements for mobile */
        @media (hover: none) and (pointer: coarse) {
            .toc-link {
                min-height: 44px; /* Minimum touch target size */
                display: flex;
                align-items: center;
            }

            .toc-group-header {
                min-height: 44px;
                display: flex;
                align-items: center;
            }

            .sidebar-close {
                min-width: 44px;
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .sidebar-toggle {
                min-width: 44px;
                min-height: 44px;
            }
        }

        /* Improved mobile scrolling */
        @media (max-width: 1024px) {
            .sidebar {
                -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
                scrollbar-width: none; /* Hide scrollbar on Firefox */
                -ms-overflow-style: none; /* Hide scrollbar on IE/Edge */
            }

            .sidebar::-webkit-scrollbar {
                display: none; /* Hide scrollbar on WebKit browsers */
            }

            .content-area {
                -webkit-overflow-scrolling: touch;
            }
        }

        /* Better mobile button sizing */
        @media (max-width: 768px) {
            .btn {
                min-height: 44px;
                min-width: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .sidebar-toggle {
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            }

            .sidebar-toggle:active {
                transform: scale(0.95);
            }
        }

        /* Mobile-first improvements */
        @media (max-width: 480px) {
            .header {
                padding: 10px;
            }

            .logo {
                font-size: 1.3rem;
            }

            .content-area h1,
            .content-area h2,
            .content-area h3,
            .content-area h4,
            .content-area h5,
            .content-area h6 {
                scroll-margin-top: 80px; /* Adjusted for mobile header */
            }

            /* Ensure content is readable on small screens */
            .content-area {
                font-size: 16px; /* Prevent zoom on iOS */
                line-height: 1.6;
            }

            .content-area p {
                margin-bottom: 1rem;
            }

            .content-area table {
                font-size: 14px;
                overflow-x: auto;
                display: block;
            }
        }

        /* Landscape mobile improvements */
        @media (max-width: 1024px) and (orientation: landscape) {
            .sidebar {
                width: 60%;
                max-width: 400px;
            }

            .content-area {
                margin-left: 0;
            }
        }

        /* Share modal */
        .modal-overlay { 
            position: fixed; 
            inset: 0; 
            background: rgba(0,0,0,0.7); 
            display: none; 
            align-items: center; 
            justify-content: center; 
            z-index: 10000;
            backdrop-filter: blur(4px);
        }
        .modal { 
            background: #fff; 
            width: min(650px, 96vw); 
            max-height: 90vh; 
            border-radius: 16px; 
            box-shadow: 0 25px 60px rgba(0,0,0,0.25); 
            display: flex; 
            flex-direction: column; 
            overflow: hidden;
            animation: modalSlideIn 0.3s ease-out;
        }
        @keyframes modalSlideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .modal-header { 
            padding: 24px 30px 20px; 
            border-bottom: 1px solid #e9ecef; 
            display: flex; 
            align-items: center; 
            justify-content: space-between;
            background: linear-gradient(135deg, #f8f9ff 0%, #ffffff 100%);
        }
        .modal-title { 
            font-weight: 700; 
            color: #2c3e50; 
            font-size: 1.4rem;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .modal-title i {
            color: #667eea;
            font-size: 1.2rem;
        }
        .modal-body { 
            padding: 30px; 
            overflow: auto;
            background: #ffffff;
        }
        .modal-footer { 
            padding: 20px 30px; 
            border-top: 1px solid #e9ecef; 
            display: flex; 
            align-items: center; 
            justify-content: flex-end; 
            gap: 15px;
            background: #f8f9fa;
        }
        .input { 
            width: 100%; 
            padding: 14px 16px; 
            border: 2px solid #e9ecef; 
            border-radius: 10px; 
            font-size: 14px; 
            transition: all 0.3s ease;
            font-family: inherit;
            background: #ffffff;
        }
        .input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .input[readonly] {
            background: #f8f9fa;
            border-color: #dee2e6;
            color: #6c757d;
            cursor: not-allowed;
        }
        .hint { 
            color: #6c757d; 
            font-size: 13px; 
            margin-top: 8px;
            font-style: italic;
        }
        .btn.small { 
            padding: 12px 20px; 
            border-radius: 10px; 
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        .btn.small:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }
        .form-group {
            margin-bottom: 24px;
        }
        .form-group label {
            display: block;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 0.95rem;
        }
        .form-group:last-child {
            margin-bottom: 0;
        }

        /* Read-only shared view: disable text selection */
        .no-select {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="logo">
                <i class="fas fa-file-pdf"></i> Documenta Viewer
            </div>
            <div class="header-actions">
                <a href="/projects" class="btn secondary">
                    <i class="fas fa-home"></i> Home
                </a>
                <a href="/edit/{{ unique_id }}" class="btn" id="editBtnViewer">
                    <i class="fas fa-edit"></i> Edit Document
                </a>
                <div class="btn secondary" id="optionsBtn">
                    <i class="fas fa-ellipsis-v"></i> Options
                </div>
            </div>
        </div>
    </div>

    <button class="sidebar-toggle" id="sidebar-toggle" title="Toggle Sidebar">
        <i class="fas fa-bars"></i>
    </button>
    
    <div class="main-content">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">
                    <i class="fas fa-list"></i> Table of Contents
                </div>
                <button class="sidebar-close" id="sidebar-close" title="Close sidebar">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <ul class="toc-list" id="toc-list">
                <li class="toc-item">
                    <div class="loading">
                        <div class="spinner"></div>
                        Loading...
                    </div>
                </li>
            </ul>
        </div>

        <div class="content-area">
            <div class="loading" id="content-loading">
                <div class="spinner"></div>
                Loading document...
            </div>
            <div id="document-content" style="display: none;"></div>
        </div>
    </div>

    <script>
        // Options menu
        (function(){
            const btn = document.getElementById('optionsBtn');
            if (!btn) return;
            const menu = document.createElement('div');
            menu.style.position = 'absolute';
            menu.style.right = '30px';
            menu.style.top = '60px';
            menu.style.background = '#fff';
            menu.style.border = '1px solid #e9ecef';
            menu.style.borderRadius = '8px';
            menu.style.boxShadow = '0 4px 12px rgba(0,0,0,0.08)';
            menu.style.padding = '8px 0';
            menu.style.display = 'none';
            menu.style.minWidth = '180px';
            menu.style.zIndex = '2000';
            menu.innerHTML = `
                <a href="#" id="downloadLink" style="display:block; padding:10px 16px; color:#2c3e50; text-decoration:none;"><i class="fas fa-download"></i> Download</a>
                <a href="#" id="shareLink" style="display:block; padding:10px 16px; color:#2c3e50; text-decoration:none;"><i class="fas fa-share"></i> Share</a>
                <a href="#" id="deleteLink" style="display:block; padding:10px 16px; color:#dc3545; text-decoration:none;"><i class="fas fa-trash"></i> Delete</a>
            `;
            document.body.appendChild(menu);
            btn.addEventListener('click', () => {
                menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
            });
            document.addEventListener('click', (e) => {
                if (!btn.contains(e.target) && !menu.contains(e.target)) menu.style.display = 'none';
            });
            document.getElementById('shareLink').addEventListener('click', async (e) => {
                e.preventDefault();
                openShareModal();
                menu.style.display = 'none';
            });
            document.getElementById('deleteLink').addEventListener('click', async (e) => {
                e.preventDefault();
                
                // Show styled delete confirmation modal
                const confirmed = await showDeleteConfirmation();
                if (!confirmed) return;
                
                try {
                    const tok = document.getElementById('deleteLink').getAttribute('data-token') || '';
                    const res = await fetch(`/api/delete/{{ unique_id }}?token=${encodeURIComponent(tok)}`, { method: 'DELETE' });
                    const json = await res.json();
                    if (json.success) { window.location.href = '/projects'; } else { alert(json.error || 'Delete failed'); }
                } catch { alert('Delete failed'); }
            });
        })();

        const uniqueId = '{{ unique_id }}';
        let currentToken = null;
        const isShared = new URLSearchParams(location.search).get('share') === '1';
        // Remove the problematic redirect that prevents shared documents from being viewed
        // if (isShared) {
        //     try { sessionStorage.setItem('readonlyMode', '1'); } catch (_) {}
        //     try { window.location.replace('/projects'); } catch (_) { window.location.href = '/projects'; }
        // }
        // Instead, just set readonly mode for shared documents
        if (isShared) {
            try { sessionStorage.setItem('readonlyMode', '1'); } catch (_) {}
        }
        const isForcedReadonly = (()=>{ try { return sessionStorage.getItem('readonlyMode') === '1'; } catch(_) { return false; } })();
        if (isShared || isForcedReadonly) {
            const eb = document.getElementById('editBtnViewer');
            if (eb) eb.style.display = 'none';
            const dl = document.getElementById('downloadLink');
            if (dl) dl.style.display = 'none';
            const opt = document.getElementById('optionsBtn');
            if (opt) opt.style.display = 'none';
            // Keep Home visible so users can navigate back easily
            // Note: selection/copy prevention is now enforced for all viewer modes below
        }
        const tocList = document.getElementById('toc-list');
        const contentLoading = document.getElementById('content-loading');
        const documentContent = document.getElementById('document-content');

        // Helper: generate slug from heading text for IDs
        function slugify(text) {
            return (text || '')
                .toString()
                .toLowerCase()
                .trim()
                .replace(/[^a-z0-9\s-]/g, '')
                .replace(/\s+/g, '-')
                .replace(/-+/g, '-');
        }

        // Secure links: fetch edit/download token when not shared
        (async function secureLinks(){
            try {
                if (isShared || isForcedReadonly) return;
                const res = await fetch(`/api/token/${uniqueId}`);
                const data = await res.json();
                if (data && data.token) {
                    currentToken = data.token;
                    const eb = document.getElementById('editBtnViewer');
                    if (eb) eb.href = `/edit/${uniqueId}?token=${encodeURIComponent(data.token)}`;
                    const dl = document.getElementById('downloadLink');
                    if (dl) dl.href = `/download/${uniqueId}?token=${encodeURIComponent(data.token)}`;
                    const del = document.getElementById('deleteLink');
                    if (del) del.setAttribute('data-token', data.token);
                } else {
                    // If token retrieval fails, disable edit/download rather than redirecting to editor
                    const eb = document.getElementById('editBtnViewer');
                    if (eb) eb.style.display = 'none';
                    const dl = document.getElementById('downloadLink');
                    if (dl) dl.style.display = 'none';
                }
            } catch(e) { /* ignore */ }
        })();

        // Load the document content
        async function loadDocument() {
            try {
                const response = await fetch(`/api/content/${uniqueId}`);
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }

                // Extract the content from the HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(data.content, 'text/html');
                
                // Extract main content
                const mainContent = doc.querySelector('.main-content');
                if (mainContent) {
                    documentContent.innerHTML = mainContent.innerHTML;
                } else {
                    documentContent.innerHTML = data.content;
                }

                // Show content
                contentLoading.style.display = 'none';
                documentContent.style.display = 'block';
                // Clear TOC loading state immediately
                tocList.innerHTML = '';

                // Enforce no-selection/no-copy for the displayed content in all viewer modes
                try {
                    const scope = document.querySelector('.content-area');
                    if (scope) {
                        scope.classList.add('no-select');
                        const prevent = (e) => { e.preventDefault(); };
                        ['selectstart','copy','contextmenu'].forEach(evt => {
                            scope.addEventListener(evt, prevent, { passive: false });
                        });
                    }
                } catch (_) { /* ignore */ }

                // For shared view: set header title to document title and provide an Open button only
                if (isShared) {
                    let docTitle = '';
                    try {
                        const headTitle = (doc.querySelector('title') && doc.querySelector('title').textContent) || '';
                        const firstH1 = (documentContent.querySelector('h1') && documentContent.querySelector('h1').textContent) || '';
                        docTitle = (firstH1 || headTitle || 'Document').trim();
                    } catch (_) { docTitle = 'Document'; }
                    const logo = document.querySelector('.logo');
                    if (logo) logo.innerHTML = `<i class="fas fa-file-pdf"></i> ${docTitle}`;
                    const actions = document.querySelector('.header-actions');
                    if (actions) {
                        // remove all children then add just Open button
                        actions.innerHTML = '';
                        const openBtn = document.createElement('a');
                        openBtn.href = '#';
                        openBtn.className = 'btn';
                        openBtn.innerHTML = '<i class="fas fa-folder-open"></i> Open';
                        openBtn.addEventListener('click', (e)=>{
                            e.preventDefault();
                            const header = document.querySelector('.header');
                            const headerH = header ? header.offsetHeight : 0;
                            const y = document.querySelector('.content-area').getBoundingClientRect().top + window.scrollY - headerH - 10;
                            window.scrollTo({ top: y, behavior: 'smooth' });
                        });
                        actions.appendChild(openBtn);
                    }
                }

                // Build TOC from the displayed content to ensure IDs exist and link properly
                // Wait for content to be fully loaded and rendered before building TOC
                
                // Show loading state in TOC while waiting
                tocList.innerHTML = '<li class="toc-item"><div class="loading"><div class="spinner"></div> Preparing table of contents...</div></li>';
                
                function waitForContentReady() {
                    return new Promise((resolve) => {
                        let attempts = 0;
                        const maxAttempts = 100; // Maximum 5 seconds (100 * 50ms)
                        
                        // Check if content is ready
                        const checkContent = () => {
                            attempts++;
                            const scope = documentContent;
                            
                            // Check if content element exists and has content
                            if (!scope || !scope.innerHTML || scope.innerHTML.trim() === '') {
                                if (attempts < maxAttempts) {
                                    console.log(`Content not ready yet, waiting... (attempt ${attempts}/${maxAttempts})`);
                                    setTimeout(checkContent, 50);
                                } else {
                                    console.warn('Max attempts reached, proceeding with TOC build anyway');
                                    resolve();
                                }
                                return;
                            }
                            
                            // Check if content has been rendered (has actual DOM elements)
                            const children = scope.children;
                            if (children.length === 0) {
                                if (attempts < maxAttempts) {
                                    console.log(`Content DOM not rendered yet, waiting... (attempt ${attempts}/${maxAttempts})`);
                                    setTimeout(checkContent, 50);
                                } else {
                                    console.warn('Max attempts reached, proceeding with TOC build anyway');
                                    resolve();
                                }
                                return;
                            }
                            
                            // Check if content is visible (not hidden)
                            if (scope.style.display === 'none') {
                                if (attempts < maxAttempts) {
                                    console.log(`Content not visible yet, waiting... (attempt ${attempts}/${maxAttempts})`);
                                    setTimeout(checkContent, 50);
                                } else {
                                    console.warn('Max attempts reached, proceeding with TOC build anyway');
                                    resolve();
                                }
                                return;
                            }
                            
                            // Check if content has meaningful text content (not just empty elements)
                            const hasTextContent = Array.from(scope.querySelectorAll('*')).some(el => {
                                const text = (el.textContent || '').trim();
                                return text.length > 5; // At least 5 characters of meaningful text
                            });
                            
                            if (!hasTextContent) {
                                if (attempts < maxAttempts) {
                                    console.log(`Content has no meaningful text yet, waiting... (attempt ${attempts}/${maxAttempts})`);
                                    setTimeout(checkContent, 50);
                                } else {
                                    console.warn('Max attempts reached, proceeding with TOC build anyway');
                                    resolve();
                                }
                                return;
                            }
                            
                            // Check if any dynamic content is still loading (e.g., from JavaScript)
                            const loadingElements = scope.querySelectorAll('[data-loading], .loading, [style*="opacity: 0"]');
                            if (loadingElements.length > 0) {
                                if (attempts < maxAttempts) {
                                    console.log(`Dynamic content still loading, waiting... (attempt ${attempts}/${maxAttempts})`);
                                    setTimeout(checkContent, 50);
                                } else {
                                    console.warn('Max attempts reached, proceeding with TOC build anyway');
                                    resolve();
                                }
                                return;
                            }
                            
                            // Additional check: wait for any images or external resources to load
                            const images = scope.querySelectorAll('img');
                            if (images.length > 0) {
                                let loadedImages = 0;
                                const totalImages = images.length;
                                
                                images.forEach(img => {
                                    if (img.complete) {
                                        loadedImages++;
                                    } else {
                                        img.addEventListener('load', () => {
                                            loadedImages++;
                                            if (loadedImages === totalImages) {
                                                console.log('All images loaded, content ready');
                                                resolve();
                                            }
                                        });
                                        img.addEventListener('error', () => {
                                            loadedImages++;
                                            if (loadedImages === totalImages) {
                                                console.log('All images processed, content ready');
                                                resolve();
                                            }
                                        });
                                    }
                                });
                                
                                // If all images are already loaded
                                if (loadedImages === totalImages) {
                                    console.log('All images already loaded, content ready');
                                    resolve();
                                }
                                
                                // Fallback: if images take too long, proceed anyway
                                setTimeout(() => {
                                    if (attempts < maxAttempts) {
                                        console.log('Image loading timeout, proceeding with TOC build');
                                        resolve();
                                    }
                                }, 2000); // 2 second timeout for images
                            } else {
                                // No images, content is ready
                                console.log('No images found, content ready');
                                resolve();
                            }
                        };
                        
                        // Use requestAnimationFrame to ensure DOM is fully rendered
                        const startChecking = () => {
                            requestAnimationFrame(() => {
                                // Wait one more frame to ensure everything is rendered
                                requestAnimationFrame(() => {
                                    checkContent();
                                });
                            });
                        };
                        
                        // Start checking after ensuring DOM is ready
                        if (document.readyState === 'loading') {
                            document.addEventListener('DOMContentLoaded', startChecking);
                        } else {
                            startChecking();
                        }
                    });
                }
                
                // Build TOC after content is fully ready
                waitForContentReady().then(() => {
                    console.log('Content is ready, building TOC...');
                    (function buildDisplayedTOC(){
                        try {
                            console.log('Starting TOC build...');
                            const tocItems = [];
                            const scope = documentContent;
                            
                            console.log('Document content element:', scope);
                            console.log('Document content HTML length:', scope.innerHTML.length);
                            console.log('Document content children count:', scope.children.length);
                            
                            // More flexible regex patterns for different numbering formats
                            const numberPatterns = [
                                /^\s*(\d+(?:\.\d+)*)[).]?\s+(.*)$/,  // 1.1, 1.2, etc.
                                /^\s*([IVX]+)[).]?\s+(.*)$/i,        // I, II, III, etc.
                                /^\s*([A-Z])[).]?\s+(.*)$/,          // A, B, C, etc.
                                /^\s*(\d+)[).]?\s+(.*)$/             // 1, 2, 3, etc.
                            ];
                            
                            // First try to find numbered headings
                            let list = [];
                            const headings = scope.querySelectorAll('h1,h2,h3,h4,h5,h6');
                            console.log('Found headings:', headings.length);
                            
                            for (const pattern of numberPatterns) {
                                const candidates = Array.from(headings)
                                    .filter(el => pattern.test((el.textContent || '').trim()))
                                    .filter(el => (el.textContent || '').trim().length <= 200);
                                if (candidates.length > 0) {
                                    list = candidates;
                                    console.log('Found numbered headings with pattern:', pattern, 'count:', candidates.length);
                                    break;
                                }
                            }
                            
                            // If no numbered headings, try paragraphs and divs with numbers
                            if (list.length === 0) {
                                console.log('No numbered headings found, trying paragraphs and divs...');
                                for (const pattern of numberPatterns) {
                                    const candidates = Array.from(scope.querySelectorAll('p,li,div'))
                                        .filter(el => pattern.test((el.textContent || '').trim()))
                                        .filter(el => (el.textContent || '').trim().length <= 200);
                                    if (candidates.length > 0) {
                                        list = candidates;
                                        console.log('Found numbered content with pattern:', pattern, 'count:', candidates.length);
                                        break;
                                    }
                                }
                            }
                            
                            // Last resort: any headings
                            if (list.length === 0) {
                                console.log('No numbered content found, using all headings...');
                                list = Array.from(scope.querySelectorAll('h1,h2,h3,h4,h5,h6'));
                                console.log('All headings count:', list.length);
                            }
                            
                            // If still nothing, try any content that might be a section
                            if (list.length === 0) {
                                console.log('No headings found, trying paragraphs and divs as sections...');
                                list = Array.from(scope.querySelectorAll('p,div'))
                                    .filter(el => (el.textContent || '').trim().length > 10 && (el.textContent || '').trim().length <= 200);
                                console.log('Potential section elements count:', list.length);
                            }
                            
                            console.log('Final list for TOC:', list.length, 'items');
                            
                            // Parse and group TOC items
                            const groupedItems = {};
                            list.forEach((el, index) => {
                                const text = (el.textContent || '').trim();
                                if (!text) return;
                                
                                console.log('Processing element:', el.tagName, 'text:', text.substring(0, 50));
                                
                                if (!el.id) {
                                    let base = slugify(text);
                                    // Ensure ID doesn't start with a digit (problematic for CSS selectors)
                                    if (/^[0-9]/.test(base)) base = `s-${base}`;
                                    let id = base || `section-${index+1}`;
                                    let counter = 2;
                                    while (document.getElementById(id)) { id = `${base}-${counter++}`; }
                                    el.id = id;
                                    console.log('Generated ID:', id, 'for text:', text.substring(0, 30));
                                }
                                
                                // Try to match with any of the number patterns
                                let match = null;
                                let patternIndex = -1;
                                
                                for (let i = 0; i < numberPatterns.length; i++) {
                                    const testMatch = text.match(numberPatterns[i]);
                                    if (testMatch) {
                                        match = testMatch;
                                        patternIndex = i;
                                        break;
                                    }
                                }
                                if (match) {
                                    const number = match[1];
                                    const title = match[2];
                                    
                                    // Handle different numbering formats
                                    let mainSection, parts;
                                    if (patternIndex === 0) {
                                        // Decimal format: 1.1, 1.2, etc.
                                        parts = number.split('.');
                                        mainSection = parts[0];
                                    } else if (patternIndex === 1) {
                                        // Roman numerals: I, II, III, etc.
                                        parts = [number];
                                        mainSection = number;
                                    } else if (patternIndex === 2) {
                                        // Letters: A, B, C, etc.
                                        parts = [number];
                                        mainSection = number;
                                    } else {
                                        // Simple numbers: 1, 2, 3, etc.
                                        parts = [number];
                                        mainSection = number;
                                    }
                                    
                                    if (!groupedItems[mainSection]) {
                                        // Try to find a better title for the main section
                                        let sectionTitle = `Section ${mainSection}`;
                                        const mainSectionEl = list.find(el => {
                                            const text = el.textContent.trim();
                                            for (const pattern of numberPatterns) {
                                                const testMatch = text.match(pattern);
                                                if (testMatch && testMatch[1] === mainSection) {
                                                    // Check if it's a main section (single level)
                                                    if (patternIndex === 0) {
                                                        return testMatch[1].split('.').length === 1;
                                                    } else {
                                                        return true; // Roman, letter, or simple number
                                                    }
                                                }
                                            }
                                            return false;
                                        });
                                        if (mainSectionEl) {
                                            const text = mainSectionEl.textContent.trim();
                                            for (const pattern of numberPatterns) {
                                                const testMatch = text.match(pattern);
                                                if (testMatch && testMatch[1] === mainSection) {
                                                    sectionTitle = testMatch[2];
                                                    break;
                                                }
                                            }
                                        }
                                        groupedItems[mainSection] = {
                                            title: sectionTitle,
                                            items: []
                                        };
                                    }
                                    
                                    groupedItems[mainSection].items.push({
                                        href: `#${el.id}`,
                                        text: title,
                                        number: number,
                                        level: parts.length
                                    });
                                } else {
                                    // Fallback for items without clear numbering
                                    if (!groupedItems['other']) {
                                        groupedItems['other'] = {
                                            title: 'Other Sections',
                                            items: []
                                        };
                                    }
                                    groupedItems['other'].items.push({
                                        href: `#${el.id}`,
                                        text: text,
                                        number: '',
                                        level: 1
                                    });
                                }
                            });
                            
                            console.log('Grouped items:', groupedItems);
                            console.log('Grouped items keys:', Object.keys(groupedItems));
                            
                            tocList.innerHTML = '';
                            if (Object.keys(groupedItems).length === 0) {
                                console.log('No grouped items found, showing "No sections found" message');
                                // Fallback: show basic content structure
                                const fallbackItems = [];
                                const allElements = scope.querySelectorAll('p, div, h1, h2, h3, h4, h5, h6, li');
                                
                                allElements.forEach((el, index) => {
                                    const text = (el.textContent || '').trim();
                                    if (text && text.length > 5 && text.length < 200) {
                                        if (!el.id) {
                                            let base = slugify(text);
                                            if (/^[0-9]/.test(base)) base = `s-${base}`;
                                            let id = base || `content-${index+1}`;
                                            let counter = 2;
                                            while (document.getElementById(id)) { id = `${base}-${counter++}`; }
                                            el.id = id;
                                        }
                                        
                                        fallbackItems.push({
                                            href: `#${el.id}`,
                                            text: text.length > 50 ? text.substring(0, 50) + '...' : text,
                                            tag: el.tagName.toLowerCase()
                                        });
                                    }
                                });
                                
                                if (fallbackItems.length > 0) {
                                    console.log('Showing fallback TOC with', fallbackItems.length, 'items');
                                    const fallbackLi = document.createElement('li');
                                    fallbackLi.className = 'toc-item';
                                    fallbackLi.innerHTML = '<div style="color:#6c757d; font-weight:600; margin-bottom:10px;">Document Content</div>';
                                    tocList.appendChild(fallbackLi);
                                    
                                    fallbackItems.forEach(item => {
                                        const itemLi = document.createElement('li');
                                        itemLi.className = 'toc-item';
                                        itemLi.innerHTML = `<a href="${item.href}" class="toc-link" data-target="${item.href}"><span style="color:#6c757d; font-size:0.8em;">[${item.tag}]</span> ${item.text}</a>`;
                                        tocList.appendChild(itemLi);
                                    });
                                } else {
                                    tocList.innerHTML = '<li class="toc-item" style="color:#6c757d;">No sections found</li>';
                                }
                                return;
                            }
                            
                            // Build grouped TOC HTML
                            Object.keys(groupedItems).sort((a, b) => {
                                if (a === 'other') return 1;
                                if (b === 'other') return -1;
                                return parseInt(a) - parseInt(b);
                            }).forEach(sectionKey => {
                                const section = groupedItems[sectionKey];
                                console.log('Building TOC for section:', sectionKey, 'with', section.items.length, 'items');
                                
                                if (section.items.length === 1 && section.items[0].level === 1) {
                                    // Single main section item
                                    const li = document.createElement('li');
                                    li.className = 'toc-item';
                                    li.innerHTML = `<a href="${section.items[0].href}" class="toc-link" data-target="${section.items[0].href}">${section.items[0].text}</a>`;
                                    tocList.appendChild(li);
                                    console.log('Added single item TOC entry for:', section.items[0].text);
                                } else {
                                    // Grouped section with expandable content
                                    const groupLi = document.createElement('li');
                                    groupLi.className = 'toc-group';
                                    
                                    const groupHeader = document.createElement('div');
                                    groupHeader.className = 'toc-group-header';
                                    groupHeader.innerHTML = `
                                        <span>${section.title}</span>
                                        <button class="toc-group-toggle" type="button">
                                            <i class="fas fa-chevron-right"></i>
                                        </button>
                                    `;
                                    
                                    const groupContent = document.createElement('div');
                                    groupContent.className = 'toc-group-content';
                                    
                                    // Sort items by their numbering
                                    section.items.sort((a, b) => {
                                        if (!a.number || !b.number) return 0;
                                        const aParts = a.number.split('.').map(Number);
                                        const bParts = b.number.split('.').map(Number);
                                        for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
                                            const aVal = aParts[i] || 0;
                                            const bVal = bParts[i] || 0;
                                            if (aVal !== bVal) return aVal - bVal;
                                        }
                                        return 0;
                                    });
                                    
                                    section.items.forEach(item => {
                                        const itemLi = document.createElement('li');
                                        itemLi.className = 'toc-item';
                                        itemLi.innerHTML = `<a href="${item.href}" class="toc-link" data-target="${item.href}">${item.number ? item.number + ' ' : ''}${item.text}</a>`;
                                        groupContent.appendChild(itemLi);
                                        console.log('Added grouped TOC item:', item.text, 'with href:', item.href);
                                    });
                                    
                                    groupLi.appendChild(groupHeader);
                                    groupLi.appendChild(groupContent);
                                    tocList.appendChild(groupLi);
                                    console.log('Added grouped TOC section:', section.title);
                                    
                                    // Add click handler for group header
                                    groupHeader.addEventListener('click', () => {
                                        const isExpanded = groupHeader.classList.contains('expanded');
                                        if (isExpanded) {
                                            groupHeader.classList.remove('expanded');
                                            groupHeader.querySelector('.toc-group-toggle').classList.remove('expanded');
                                            groupContent.classList.remove('expanded');
                                        } else {
                                            groupHeader.classList.add('expanded');
                                            groupHeader.querySelector('.toc-group-toggle').classList.add('expanded');
                                            groupContent.classList.add('expanded');
                                        }
                                    });
                                    
                                    // Expand the first section by default
                                    if (index === 0) {
                                        groupHeader.classList.add('expanded');
                                        groupHeader.querySelector('.toc-group-toggle').classList.add('expanded');
                                        groupContent.classList.add('expanded');
                                    }
                                }
                            });
                            
                            console.log('TOC building completed. Final TOC HTML length:', tocList.innerHTML.length);
                            
                            // Smooth scrolling within content
                            tocList.querySelectorAll('.toc-link').forEach(link => {
                                link.addEventListener('click', (e) => {
                                    e.preventDefault();
                                    const selector = link.getAttribute('data-target') || '';
                                    const id = selector.startsWith('#') ? selector.slice(1) : selector;
                                    const target = document.getElementById(id);
                                    if (target) {
                                        const header = document.querySelector('.header');
                                        const headerH = header ? header.offsetHeight : 0;
                                        const y = window.scrollY + target.getBoundingClientRect().top - headerH - 10;
                                        window.scrollTo({ top: y, behavior: 'smooth' });
                                        try { history.replaceState(null, '', `#${id}`); } catch (_) {}
                                    }
                                });
                            });
                        } catch (err) {
                            console.error('TOC build error:', err);
                            tocList.innerHTML = '<li class="toc-item" style="color:#dc3545;">Failed to build table of contents</li>';
                            // Optionally log error
                            console.warn('TOC build error', err);
                        }
                    })();
                }).catch(error => {
                    console.error('Error waiting for content to be ready:', error);
                    tocList.innerHTML = '<li class="toc-item" style="color:#dc3545;">Failed to load content for TOC</li>';
                });

                // If URL already has a hash, scroll to it with offset once content is ready
                if (location.hash) {
                    const id = location.hash.slice(1);
                    const target = document.getElementById(id);
                    if (target) {
                        const header = document.querySelector('.header');
                        const headerH = header ? header.offsetHeight : 0;
                        const y = window.scrollY + target.getBoundingClientRect().top - headerH - 10;
                        window.scrollTo({ top: y });
                    }
                }

            } catch (error) {
                contentLoading.innerHTML = `
                    <div style="text-align: center; color: #dc3545;">
                        <i class="fas fa-exclamation-triangle" style="font-size: 3rem; margin-bottom: 20px;"></i>
                        <h3>Error Loading Document</h3>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }

        // Load document when page loads
        loadDocument();

        // --- Share Modal ---
        const shareModal = document.createElement('div');
        shareModal.id = 'shareModal';
        shareModal.className = 'modal-overlay';
        shareModal.innerHTML = `
            <div class="modal">
                <div class="modal-header">
                    <div class="modal-title"><i class="fas fa-share"></i> Share Document</div>
                    <button class="btn small secondary" id="shareCloseBtn"><i class="fas fa-times"></i></button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="shareEmails">Recipient Emails</label>
                        <textarea id="shareEmails" class="input" rows="4" placeholder="e.g. user@example.com, team@company.com"></textarea>
                        <div class="hint">Separate multiple emails with commas or new lines.</div>
                    </div>
                    
                    <div class="form-group">
                        <label for="shareMessage">Message (optional)</label>
                        <textarea id="shareMessage" class="input" rows="3" placeholder="Add a note (optional)"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label>View Link</label>
                        <input id="shareLinkInput" class="input" type="text" readonly />
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn small secondary" id="shareCancelBtn">Cancel</button>
                    <button class="btn small" id="shareSendBtn" disabled><i class="fas fa-paper-plane"></i> Send</button>
                </div>
            </div>`;
        document.body.appendChild(shareModal);

        const shareEmailsEl = shareModal.querySelector('#shareEmails');
        const shareMessageEl = shareModal.querySelector('#shareMessage');
        const shareLinkEl   = shareModal.querySelector('#shareLinkInput');
        const shareSendBtn  = shareModal.querySelector('#shareSendBtn');
        const shareCancelBtn= shareModal.querySelector('#shareCancelBtn');
        const shareCloseBtn = shareModal.querySelector('#shareCloseBtn');

        function openShareModal() {
            shareLinkEl.value = `${window.location.origin}/view/${uniqueId}?share=1`;
            shareEmailsEl.value = '';
            shareMessageEl.value = '';
            shareSendBtn.disabled = true;
            shareModal.style.display = 'flex';
            shareEmailsEl.focus();
        }
        function closeShareModal() { shareModal.style.display = 'none'; }
        function parseEmails(input) {
            return (input || '')
                .split(/[,\n;]/)
                .map(s => s.trim())
                .filter(Boolean);
        }
        function isValidEmail(e) { return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(e); }
        function validateShareForm() {
            const emails = parseEmails(shareEmailsEl.value);
            const ok = emails.length > 0 && emails.every(isValidEmail);
            shareSendBtn.disabled = !ok;
            return ok ? emails : [];
        }
        shareEmailsEl.addEventListener('input', validateShareForm);
        shareCancelBtn.addEventListener('click', (e)=>{ e.preventDefault(); closeShareModal(); });
        shareCloseBtn.addEventListener('click', (e)=>{ e.preventDefault(); closeShareModal(); });
        shareModal.addEventListener('click', (e)=>{ if (e.target === shareModal) closeShareModal(); });
        shareSendBtn.addEventListener('click', async () => {
            const emails = validateShareForm();
            if (emails.length === 0) return;
            const payload = {
                emails,
                link: shareLinkEl.value,
                message: shareMessageEl.value || ''
            };
            try {
                // optional server stub; ok if token missing
                const url = currentToken ? `/api/share/${uniqueId}?token=${encodeURIComponent(currentToken)}` : `/api/share/${uniqueId}`;
                await fetch(url, { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
            } catch (_) { /* ignore stub errors */ }
            closeShareModal();
            try { await navigator.clipboard.writeText(shareLinkEl.value); } catch (_) {}
            alert('Share queued. Recipients will receive the view link.');
        });

        // --- Delete Confirmation Modal ---
        function showDeleteConfirmation() {
            return new Promise((resolve) => {
                // Create modal HTML if it doesn't exist
                let modal = document.getElementById('deleteConfirmModal');
                if (!modal) {
                    modal = createDeleteModal();
                    document.body.appendChild(modal);
                }

                // Show modal
                modal.classList.add('show');
                
                // Focus the cancel button by default (safer choice)
                const cancelBtn = modal.querySelector('.delete-modal-cancel');
                cancelBtn.focus();

                // Handle confirm
                const handleConfirm = () => {
                    hideModal();
                    resolve(true);
                };

                // Handle cancel
                const handleCancel = () => {
                    hideModal();
                    resolve(false);
                };

                // Handle escape key
                const handleKeyDown = (e) => {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        handleCancel();
                    }
                };

                // Hide modal
                const hideModal = () => {
                    modal.classList.remove('show');
                    
                    // Remove event listeners
                    modal.querySelector('.delete-modal-confirm').removeEventListener('click', handleConfirm);
                    modal.querySelector('.delete-modal-cancel').removeEventListener('click', handleCancel);
                    document.removeEventListener('keydown', handleKeyDown);
                };

                // Add event listeners
                modal.querySelector('.delete-modal-confirm').addEventListener('click', handleConfirm);
                modal.querySelector('.delete-modal-cancel').addEventListener('click', handleCancel);
                document.addEventListener('keydown', handleKeyDown);
            });
        }

        function createDeleteModal() {
            const modal = document.createElement('div');
            modal.id = 'deleteConfirmModal';
            modal.className = 'delete-modal-overlay';
            modal.innerHTML = `
                <div class="delete-modal-content">
                    <div class="delete-modal-header">
                        <h3><i class="fas fa-exclamation-triangle"></i> Delete Document</h3>
                    </div>
                    <div class="delete-modal-body">
                        <p>Are you sure you want to delete this document?</p>
                        <p class="delete-warning">This action cannot be undone.</p>
                        <div class="delete-modal-actions">
                            <button class="btn secondary delete-modal-cancel">Cancel</button>
                            <button class="btn danger delete-modal-confirm">Delete Document</button>
                        </div>
                    </div>
                </div>
            `;
            return modal;
        }

        // --- Sidebar Toggle Functionality ---
        (function() {
            const sidebarToggle = document.getElementById('sidebar-toggle');
            const sidebar = document.getElementById('sidebar'); // Changed to getElementById
            const mainContent = document.querySelector('.main-content');
            const sidebarCloseBtn = document.getElementById('sidebar-close'); // New close button
            
            if (!sidebarToggle || !sidebar || !mainContent || !sidebarCloseBtn) return;
            
            // Check if sidebar was previously collapsed
            const wasCollapsed = localStorage.getItem('sidebar-collapsed') === 'true';
            if (wasCollapsed) {
                sidebar.classList.add('collapsed');
                mainContent.classList.add('sidebar-collapsed');
                sidebarToggle.classList.add('collapsed');
                sidebarCloseBtn.style.display = 'block'; // Show close button when collapsed
            }
            
            sidebarToggle.addEventListener('click', () => {
                const isCollapsed = sidebar.classList.contains('collapsed');
                
                if (isCollapsed) {
                    // Expand sidebar
                    sidebar.classList.remove('collapsed');
                    mainContent.classList.remove('sidebar-collapsed');
                    sidebarToggle.classList.remove('collapsed');
                    sidebarCloseBtn.style.display = 'none'; // Hide close button when expanded
                    localStorage.setItem('sidebar-collapsed', 'false');
                } else {
                    // Collapse sidebar
                    sidebar.classList.add('collapsed');
                    mainContent.classList.add('sidebar-collapsed');
                    sidebarToggle.classList.add('collapsed');
                    sidebarCloseBtn.style.display = 'block'; // Show close button when collapsed
                    localStorage.setItem('sidebar-collapsed', 'true');
                }
            });

            sidebarCloseBtn.addEventListener('click', () => {
                sidebar.classList.add('collapsed');
                mainContent.classList.add('sidebar-collapsed');
                sidebarToggle.classList.add('collapsed');
                sidebarCloseBtn.style.display = 'block';
                localStorage.setItem('sidebar-collapsed', 'true');
            });
            
            // Keyboard shortcut: Ctrl/Cmd + B to toggle sidebar
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
                    e.preventDefault();
                    sidebarToggle.click();
                }
            });

            // Mobile-specific improvements
            const isMobile = window.innerWidth <= 1024;
            
            if (isMobile) {
                // On mobile, start with sidebar collapsed
                if (!wasCollapsed) {
                    sidebar.classList.add('collapsed');
                    mainContent.classList.add('sidebar-collapsed');
                    sidebarToggle.classList.add('collapsed');
                    sidebarCloseBtn.style.display = 'block';
                    localStorage.setItem('sidebar-collapsed', 'true');
                }

                // Close sidebar when clicking on content area on mobile
                mainContent.addEventListener('click', () => {
                    if (!sidebar.classList.contains('collapsed')) {
                        sidebar.classList.add('collapsed');
                        mainContent.classList.add('sidebar-collapsed');
                        sidebarToggle.classList.add('collapsed');
                        sidebarCloseBtn.style.display = 'block';
                        localStorage.setItem('sidebar-collapsed', 'true');
                    }
                });

                // Prevent content clicks from closing sidebar when clicking on sidebar itself
                sidebar.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }

            // Handle window resize
            window.addEventListener('resize', () => {
                const newIsMobile = window.innerWidth <= 1024;
                
                if (newIsMobile && !isMobile) {
                    // Switched to mobile - ensure sidebar is collapsed
                    sidebar.classList.add('collapsed');
                    mainContent.classList.add('sidebar-collapsed');
                    sidebarToggle.classList.add('collapsed');
                    sidebarCloseBtn.style.display = 'block';
                    localStorage.setItem('sidebar-collapsed', 'true');
                } else if (!newIsMobile && isMobile) {
                    // Switched to desktop - restore previous state
                    const wasCollapsed = localStorage.getItem('sidebar-collapsed') === 'true';
                    if (!wasCollapsed) {
                        sidebar.classList.remove('collapsed');
                        mainContent.classList.remove('sidebar-collapsed');
                        sidebarToggle.classList.remove('collapsed');
                        sidebarCloseBtn.style.display = 'none';
                    }
                }
            });
        })();
    </script>
</body>
</html> 